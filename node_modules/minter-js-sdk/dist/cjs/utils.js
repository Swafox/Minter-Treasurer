'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _typeof = require('@babel/runtime/helpers/typeof');
var Big = require('big.js');
var BN = require('bn.js');
var ethjsUtil = require('ethjs-util');
var minterjsUtil = require('minterjs-util');
var minterjsWallet = require('minterjs-wallet');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var Big__default = /*#__PURE__*/_interopDefaultLegacy(Big);
var BN__default = /*#__PURE__*/_interopDefaultLegacy(BN);

Big__default["default"].RM = 2;
var BASE_COIN = {
  '0x01': 'BIP',
  '0x02': 'MNT'
};
/**
 * @param {number|string} chainId
 * @return {string}
 */

function normalizeChainId(chainId) {
  if (typeof chainId === 'string' || typeof chainId === 'number') {
    chainId = integerToHexString(chainId);
  }

  return chainId;
}
/**
 * @param {number|string} chainId
 * @param {string} coinSymbol
 * @return {boolean}
 */


function isBaseCoinSymbol(chainId, coinSymbol) {
  return BASE_COIN[normalizeChainId(chainId)] === coinSymbol;
}
/**
 * @param {number|string} chainId
 * @return {string|undefined}
 */

function getBaseCoinSymbol(chainId) {
  return BASE_COIN[normalizeChainId(chainId)];
}
/**
 * @param {number|string} coinIdOrSymbol
 * @return {boolean}
 */

function isCoinId(coinIdOrSymbol) {
  if (typeof coinIdOrSymbol === 'number') {
    return true;
  }

  if (typeof coinIdOrSymbol !== 'string') {
    return false;
  }

  return /^[0-9]+$/.test(coinIdOrSymbol);
}
/**
 * @param {string} coin
 * @return {boolean}
 */

function isCoinSymbol(coin) {
  if (typeof coin !== 'string') {
    return false;
  }

  return !isCoinId(coin);
}
function isValidNumber(value) {
  var invalid = typeof value !== 'number' && typeof value !== 'string' || typeof value === 'string' && value.length === 0;
  return !invalid;
}
/**
 * @param {number|string|ByteArray} num
 * @return {string}
 */

function integerToHexString(num) {
  num = toInteger(num); // handle exponential values

  num = new Big__default["default"](num).toFixed(); // convert to hex

  var hexNum = new BN__default["default"](num, 10).toString(16);
  return "0x".concat(ethjsUtil.padToEven(hexNum));
}
/**
 * @param {number|string|ByteArray} num
 * @return {string}
 */

function toInteger(num) {
  if (typeof num === 'number') {
    return num.toString();
  }

  if (typeof num !== 'undefined' && num !== null && num.length > 0) {
    // handle hex prefixed string
    if (typeof num === 'string' && ethjsUtil.isHexPrefixed(num)) {
      return bufferToInteger(num);
    } // handle arrays


    if (typeof num !== 'string') {
      return bufferToInteger(num);
    }
  }

  num = Number.parseInt(num, 10);
  return Number.isNaN(num) ? '' : num.toString();
}
/**
 * @param {ByteArray} buf
 * @return {string}
 */

function bufferToInteger(buf) {
  buf = bufferFromBytes(buf);
  return new BN__default["default"](buf, 16).toString(10);
}
/**
 * @param {ByteArray} buf
 * @return {boolean|null}
 */

function bufferToBoolean(buf) {
  buf = bufferFromBytes(buf);

  if (buf.toString('hex') === '01') {
    return true;
  }

  if (buf.toString('hex') === '') {
    return false;
  } // eslint-disable-next-line unicorn/no-null


  return null;
}
/**
 * @param {ByteArray} bytes
 * @return {Buffer}
 */

function bufferFromBytes(bytes) {
  if (bytes.length === undefined) {
    throw new Error('Invalid value passed as ByteArray, it should be Buffer, Uint8Array or hex string');
  } // string to Buffer


  if (typeof bytes === 'string') {
    bytes = bytes.replace('0x', '');
    return Buffer.from(bytes, 'hex');
  } // Uint8Array to Buffer


  if (!Buffer.isBuffer(bytes)) {
    return Buffer.from(bytes);
  } // it is Buffer already


  return bytes;
}
function proxyNestedTxData(obj) {
  addTxDataFields(obj); // proxy TxData

  obj.raw = obj.txData.raw;
  obj.serialize = obj.txData.serialize;
  obj.serializeToString = obj.txData.serializeToString;
}
function addTxDataFields(txData) {
  Object.defineProperty(txData, 'fields', {
    get: function get() {
      var fields = {};

      txData.txData._fields.forEach(function (key) {
        if (Array.isArray(txData[key])) {
          // cast multisend items to fields
          fields[key] = txData[key].map(function (item) {
            return item.fields || item;
          });
        } else {
          fields[key] = txData[key];
        }
      });

      return fields;
    },
    enumerable: true
  });
}
function validateAddress(value, fieldName) {
  validateNotEmpty(value, fieldName);

  if (typeof value === 'string' && !minterjsUtil.isValidAddress(value)) {
    throw new Error("Field `".concat(fieldName, "` is invalid address"));
  }
}
function validatePublicKey(value, fieldName) {
  validateNotEmpty(value, fieldName);

  if (typeof value === 'string' && !minterjsUtil.isValidPublicKeyString(value)) {
    throw new Error("Field `".concat(fieldName, "` is invalid public key"));
  }
}
function validateCheck(value, fieldName) {
  validateNotEmpty(value, fieldName);

  if (typeof value === 'string' && !minterjsUtil.isValidCheck(value)) {
    throw new Error("Field `".concat(fieldName, "` is invalid check string"));
  }
}
function validateAmount(value, fieldName) {
  validateNotEmpty(value, fieldName);

  if (typeof value === 'string' || typeof value === 'number') {
    var valueBig;

    try {
      valueBig = minterjsUtil.numberToBig(value);
    } catch (error) {
      throw new Error("Field `".concat(fieldName, "` is invalid number"));
    }

    if (valueBig && valueBig.lt(0)) {
      throw new Error("Field `".concat(fieldName, "` has negative amount"));
    }
  }
}
/**
 * @param {number|string} maxSupply
 * @param {number|string} initialAmount
 */

function validateMaxSupply(maxSupply, initialAmount) {
  validateAmount(maxSupply, 'maxSupply');

  if (maxSupply > minterjsUtil.COIN_MAX_MAX_SUPPLY || maxSupply < minterjsUtil.COIN_MIN_MAX_SUPPLY) {
    throw new Error("Field `maxSupply` should be between ".concat(minterjsUtil.COIN_MIN_MAX_SUPPLY, " and ").concat(minterjsUtil.COIN_MAX_MAX_SUPPLY));
  }

  if (Number(initialAmount) > Number(maxSupply)) {
    throw new Error('Field `initialAmount` should be less or equal of `maxSupply`');
  }
}
function validateUint(origValue, fieldName) {
  validateNotEmpty(origValue, fieldName);
  var value = Number(origValue);

  if (Number.isNaN(value)) {
    throw new TypeError("Field `".concat(fieldName, "` is not a number. Received: ").concat(origValue));
  }

  if (value < 0) {
    throw new Error("Field `".concat(fieldName, "` should be positive integer. Received: ").concat(value));
  }

  if (Math.round(value) !== value) {
    throw new Error("Field `".concat(fieldName, "` should be integer, decimal given"));
  }
}
function validateUintArray(origValue, fieldName) {
  if (!Array.isArray(origValue)) {
    throw new TypeError("Field `".concat(fieldName, "` is not an array"));
  }

  origValue.forEach(function (coin, index) {
    try {
      validateUint(coin, fieldName);
    } catch (error) {
      // update error message
      throw new Error(error.message.replace("`".concat(fieldName, "`"), "`".concat(fieldName, "` contain invalid item at index: ").concat(index, ", it ")));
    }
  });
}
function validateTicker(value, fieldName) {
  validateNotEmpty(value, fieldName);

  if (typeof value === 'string' && !/^[A-Z][A-Z0-9]{2,9}$/.test(value)) {
    throw new Error("Field `".concat(fieldName, "` is invalid coin symbol string"));
  }
}

function validateNotEmpty(value, fieldName) {
  if (typeof value === 'undefined') {
    throw new TypeError("Field `".concat(fieldName, "` is undefined"));
  }

  if (value === null) {
    throw new Error("Field `".concat(fieldName, "` is null"));
  }

  if (value === false) {
    throw new Error("Field `".concat(fieldName, "` is false"));
  }

  if (value === '') {
    throw new Error("Field `".concat(fieldName, "` is empty string"));
  }
}

function validateBoolean(value, fieldName) {
  if (typeof value !== 'boolean') {
    throw new TypeError("Field `".concat(fieldName, "` should be boolean, ").concat(_typeof__default["default"](value), " given"));
  }
}
/**
 * @param {string} seedPhrase
 * @return {string}
 */

function getPrivateKeyFromSeedPhrase(seedPhrase) {
  return minterjsWallet.walletFromMnemonic(seedPhrase).getPrivateKeyString();
}
/**
 * @param {string} seedPhrase
 * @return {Promise<string>}
 */

function getPrivateKeyFromSeedPhraseAsync(seedPhrase) {
  return minterjsWallet.walletFromMnemonicAsync(seedPhrase).then(function (wallet) {
    return wallet.getPrivateKeyString();
  });
}
/**
 * Promisify setTimeout
 * @param {number} time - milliseconds
 * @return {Promise}
 */

function wait(time) {
  return new Promise(function (resolve) {
    setTimeout(resolve, time);
  });
}

exports.addTxDataFields = addTxDataFields;
exports.bufferFromBytes = bufferFromBytes;
exports.bufferToBoolean = bufferToBoolean;
exports.bufferToInteger = bufferToInteger;
exports.getBaseCoinSymbol = getBaseCoinSymbol;
exports.getPrivateKeyFromSeedPhrase = getPrivateKeyFromSeedPhrase;
exports.getPrivateKeyFromSeedPhraseAsync = getPrivateKeyFromSeedPhraseAsync;
exports.integerToHexString = integerToHexString;
exports.isBaseCoinSymbol = isBaseCoinSymbol;
exports.isCoinId = isCoinId;
exports.isCoinSymbol = isCoinSymbol;
exports.isValidNumber = isValidNumber;
exports.proxyNestedTxData = proxyNestedTxData;
exports.toInteger = toInteger;
exports.validateAddress = validateAddress;
exports.validateAmount = validateAmount;
exports.validateBoolean = validateBoolean;
exports.validateCheck = validateCheck;
exports.validateMaxSupply = validateMaxSupply;
exports.validatePublicKey = validatePublicKey;
exports.validateTicker = validateTicker;
exports.validateUint = validateUint;
exports.validateUintArray = validateUintArray;
exports.wait = wait;
