'use strict';

var secp256k1 = require('secp256k1');
var hash_js = require('ethereumjs-util/dist/hash.js');
var minterjsWallet = require('minterjs-wallet');
var minterjsTx = require('minterjs-tx');
var minterjsUtil = require('minterjs-util');
var utils = require('../utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var secp256k1__default = /*#__PURE__*/_interopDefaultLegacy(secp256k1);

/**
 * @param {ByteArray} check
 * @param {ByteArray} [proof]
 * @param {TxOptions} [options]
 * @constructor
 */

function RedeemCheckTxData(_ref) {
  var check = _ref.check,
      proof = _ref.proof;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  utils.validateCheck(check, 'check'); // eslint-disable-next-line prefer-rest-params

  if (!options.password && arguments[0].password) {
    // eslint-disable-next-line prefer-rest-params
    options.password = arguments[0].password; // eslint-disable-next-line no-console

    console.warn('Check password in tx data is deprecated. Pass it as field in the second argument.');
  } // eslint-disable-next-line prefer-rest-params


  if (!options.privateKey && arguments[0].privateKey) {
    // eslint-disable-next-line prefer-rest-params
    options.privateKey = arguments[0].privateKey; // eslint-disable-next-line no-console

    console.warn('Private key in tx data is deprecated. Pass it as field in the second argument.');
  }

  this.check = minterjsUtil.checkToString(check);

  if (proof) {
    proof = minterjsUtil.toBuffer(proof);
  } else if (options.address || options.privateKey || options.seedPhrase) {
    proof = getProofWithRecovery(options);
  }

  this.txData = new minterjsTx.TxDataRedeemCheck({
    check: minterjsUtil.toBuffer(check),
    proof: proof
  });
  this.proof = proof ? "0x".concat(proof.toString('hex')) : undefined;
  utils.proxyNestedTxData(this);
}
/**
 *
 * @param {Buffer|string} check
 * @param {Buffer|string} proof
 * @return {RedeemCheckTxData}
 */

RedeemCheckTxData.fromBufferFields = function fromBufferFields(_ref2) {
  var check = _ref2.check,
      proof = _ref2.proof;
  return new RedeemCheckTxData({
    check: check,
    proof: proof
  });
};
/**
 * @param {Buffer|string} data
 * @return {RedeemCheckTxData}
 */


RedeemCheckTxData.fromRlp = function fromRlp(data) {
  return RedeemCheckTxData.fromBufferFields(new minterjsTx.TxDataRedeemCheck(data));
};
/**
 * @param {ByteArray} password
 * @param {ByteArray} [address]
 * @param {ByteArray} [privateKey]
 * @param {string} [seedPhrase]
 * @return {ArrayBuffer|Buffer}
 */


function getProofWithRecovery(_ref3) {
  var password = _ref3.password,
      address = _ref3.address,
      privateKey = _ref3.privateKey,
      seedPhrase = _ref3.seedPhrase;
  var addressBuffer;

  if (address) {
    addressBuffer = minterjsUtil.toBuffer(address);
  } else if (privateKey) {
    privateKey = minterjsUtil.toBuffer(privateKey);
    addressBuffer = minterjsWallet.walletFromPrivateKey(privateKey).getAddress();
  } else if (seedPhrase) {
    addressBuffer = minterjsWallet.walletFromMnemonic(seedPhrase).getAddress();
  } else {
    throw new Error('No address nor seed phrase nor private key given to generate proof');
  }

  var addressHash = hash_js.rlphash([addressBuffer]); // ensure Buffer

  password = typeof password === 'string' ? Buffer.from(password, 'utf-8') : minterjsUtil.toBuffer(password);
  var passwordBuffer = hash_js.sha256(password);
  var proof = secp256k1__default["default"].ecdsaSign(addressHash, passwordBuffer);
  var proofWithRecovery = Buffer.alloc(65);
  proofWithRecovery.set(proof.signature, 0);
  proofWithRecovery[64] = proof.recid;
  return proofWithRecovery;
}

module.exports = RedeemCheckTxData;
