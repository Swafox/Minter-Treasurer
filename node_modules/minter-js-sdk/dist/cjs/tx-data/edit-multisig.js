'use strict';

var minterjsTx = require('minterjs-tx');
var minterjsUtil = require('minterjs-util');
var utils = require('../utils.js');

/**
 * @param {Array} addresses
 * @param {Array} weights
 * @param {number|string} threshold
 * @constructor
 */

function EditMultisigTxData(_ref) {
  var addresses = _ref.addresses,
      weights = _ref.weights,
      threshold = _ref.threshold;
  utils.validateUintArray(weights, 'weights');
  utils.validateUint(threshold);
  this.addresses = addresses;
  this.weights = weights;
  this.threshold = threshold;

  if (!Array.isArray(addresses)) {
    throw new TypeError('Field `addresses` is not an array');
  }

  if (addresses.length > 32) {
    throw new Error('Invalid `addresses` count, it must not be greater than 32');
  }

  if (weights.length !== addresses.length) {
    throw new Error('Invalid `weights` count, it must be equal to addresses count');
  }

  addresses.forEach(function (address, index) {
    try {
      utils.validateAddress(address, "addresses[".concat(index, "]"));
    } catch (error) {
      throw new Error("Field `addresses` contains invalid address at index: ".concat(index, ". ").concat(error.message));
    }
  });
  weights.forEach(function (weight, index) {
    if (weight > 1023 || weight < 0) {
      throw new Error("`weights` field contains invalid weight at index: ".concat(index, ", it should be between 0 and 1023"));
    }
  }); // sort arrays so different ordered lists will produce same transaction hash

  var list = addresses.map(function (item, index) {
    return {
      address: item,
      weight: weights[index]
    };
  });
  list.sort(function sortListItem(a, b) {
    if (a.address > b.address) {
      return 1;
    }

    if (a.address < b.address) {
      return -1;
    }

    return 0;
  });
  addresses = list.map(function (item) {
    return item.address;
  });
  weights = list.map(function (item) {
    return item.weight;
  });
  this.txData = new minterjsTx.TxDataEditMultisig({
    addresses: addresses.map(function (address) {
      return minterjsUtil.toBuffer(address);
    }),
    weights: weights.map(function (weight) {
      return utils.integerToHexString(weight);
    }),
    threshold: utils.integerToHexString(threshold)
  });
  utils.proxyNestedTxData(this);
}
/**
 *
 * @param {Array<Buffer>} addresses
 * @param {Array<Buffer>} weights
 * @param {Buffer|string} threshold
 * @return {EditMultisigTxData}
 */

EditMultisigTxData.fromBufferFields = function fromBufferFields(_ref2) {
  var addresses = _ref2.addresses,
      weights = _ref2.weights,
      threshold = _ref2.threshold;
  return new EditMultisigTxData({
    addresses: addresses.map(function (item) {
      return minterjsUtil.addressToString(item);
    }),
    weights: weights.map(function (item) {
      return utils.bufferToInteger(item);
    }),
    threshold: utils.bufferToInteger(threshold)
  });
};
/**
 * @param {Buffer|string} data
 * @return {EditMultisigTxData}
 */


EditMultisigTxData.fromRlp = function fromRlp(data) {
  return EditMultisigTxData.fromBufferFields(new minterjsTx.TxDataEditMultisig(data));
};

module.exports = EditMultisigTxData;
