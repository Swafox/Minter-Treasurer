'use strict';

var minterjsTx = require('minterjs-tx');
var minterjsUtil = require('minterjs-util');
var send = require('./send.js');
var utils = require('../utils.js');

/**
 * @param {Array} list
 * @constructor
 */

function MultisendTxData(_ref) {
  var list = _ref.list;

  if (!Array.isArray(list)) {
    throw new TypeError('Field `list` is not an array');
  }

  list.forEach(function (item, index) {
    try {
      utils.validateAddress(item.to, "list[".concat(index, "].to"));
      utils.validateUint(item.coin, "list[".concat(index, "].coin"));
      utils.validateAmount(item.value, "list[".concat(index, "].value"));
    } catch (error) {
      throw new Error("Field `list` contains invalid item at index ".concat(index, ". ").concat(error.message));
    }
  });
  this.list = list;
  this.txData = new minterjsTx.TxDataMultisend({
    list: list.map(function (item) {
      return {
        to: minterjsUtil.toBuffer(item.to),
        coin: utils.integerToHexString(item.coin),
        value: "0x".concat(minterjsUtil.convertToPip(item.value, 'hex'))
      };
    })
  });
  utils.proxyNestedTxData(this);
}
/**
 * @param {Array<Buffer>} list
 * @return {MultisendTxData}
 */

MultisendTxData.fromBufferFields = function fromBufferFields(_ref2) {
  var list = _ref2.list;
  return new MultisendTxData({
    list: list.map(function (item) {
      return send.fromRlp(item);
    })
  });
};
/**
 * @param {Buffer|string} data
 * @return {MultisendTxData}
 */


MultisendTxData.fromRlp = function fromRlp(data) {
  return MultisendTxData.fromBufferFields(new minterjsTx.TxDataMultisend(data));
};

module.exports = MultisendTxData;
