'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var get = require('../external/lodash-es/get.js');
var set = require('../external/lodash-es/set.js');
var minterjsUtil = require('minterjs-util');
var getCoinInfo = require('./get-coin-info.js');
var utils = require('../utils.js');

/**
 * @param {MinterApiInstance} apiInstance
 * @return {function(TxParams): (Promise<TxParams>)}
 */

function ReplaceCoinSymbol(apiInstance) {
  var replaceCoinSymbolByPath = ReplaceCoinSymbolByPath(apiInstance);
  /**
   * @param {TxParams} txParams
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<TxParams>}
   */

  return function replaceCoinSymbol(txParams, axiosOptions) {
    var pathList = getTxParamsPathList(txParams);
    return replaceCoinSymbolByPath(txParams, pathList, txParams.chainId, axiosOptions);
  };
}
/**
 *
 * @param {MinterApiInstance} apiInstance
 * @return {function(Object, Array<string>, number=, AxiosRequestConfig=): Promise<Object>}
 * @constructor
 */

function ReplaceCoinSymbolByPath(apiInstance) {
  var replaceParamsByPath = ReplaceParamsByPath(apiInstance);
  return replaceCoinSymbolByPath;
  /**
   * @param {Object} txParams
   * @param {Array<string>} pathList
   * @param {number} [chainId]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<Object>}
   */

  function replaceCoinSymbolByPath(txParams, pathList) {
    var chainId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : apiInstance.defaults.chainId;
    var axiosOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
    return replaceParamsByPath(txParams, pathList, replacer, chainId, axiosOptions); // eslint-disable-next-line no-shadow, unicorn/consistent-function-scoping

    function replacer(symbolValue, chainId, apiInstance, axiosOptions) {
      if (utils.isCoinSymbol(symbolValue)) {
        return _getCoinId(symbolValue, chainId, apiInstance, axiosOptions);
      } else {
        return Promise.resolve(symbolValue);
      }
    }
  }
}
/**
 * @param {MinterApiInstance} apiInstance
 * @return {function(txParams: Object, pathList: Array<string>, replacer: function, chainId: number=, AxiosRequestConfig=): Promise<Object>}
 * @constructor
 */

function ReplaceParamsByPath(apiInstance) {
  return replaceParamsByPath;
  /**
   * @param {Object} txParams
   * @param {Array<string>} pathList
   * @param {function(inputValue: any, number=, AxiosRequestConfig=): Promise} replacer
   * @param {number} [chainId]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<Object>}
   */

  function replaceParamsByPath(txParams, pathList, replacer) {
    var chainId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : apiInstance.defaults.chainId;
    var axiosOptions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;
    var promiseList = {};
    pathList.forEach(function (path) {
      return fillPath(path);
    });
    var promiseArray = Object.values(promiseList);
    return Promise.all(promiseArray).then(function () {
      return txParams;
    });
    /**
     * Fill promiseList by path and replace txParams value by path
     * @param {string} path
     */

    function fillPath(path) {
      var inputValue = get(txParams, path); // coinInfo promise may be used by multiple patchers


      if (!promiseList[inputValue]) {
        promiseList[inputValue] = replacer(inputValue, chainId, apiInstance, axiosOptions);
      } // append txParams patcher


      promiseList[inputValue] = promiseList[inputValue].then(function (outputValue) {
        set(txParams, path, outputValue);

        return outputValue;
      });
    }
  }
}
/**
 * @param {MinterApiInstance} apiInstance
 * @return {function(symbol: string|Array<string>, chainId: number=, axiosOptions: AxiosRequestConfig=): Promise<number>}
 */

function GetCoinId(apiInstance) {
  return getCoinId;
  /**
   * @param {string|Array<string>} symbol
   * @param {number} [chainId]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<number|Array<number>>}
   */

  function getCoinId(symbol) {
    var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : apiInstance.defaults.chainId;
    var axiosOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    return processArrayByPromise(_getCoinId, symbol, chainId, apiInstance, axiosOptions);
  }
}
/**
 * @template T
 * @param {function(value, ...otherArgs): Promise<T>} fn
 * @param {*|Array<*>} value
 * @param {...Object} otherArgs
 * @return {Promise<T|Array<T>>}
 */

function processArrayByPromise(fn, value) {
  for (var _len = arguments.length, otherArgs = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    otherArgs[_key - 2] = arguments[_key];
  }

  if (Array.isArray(value)) {
    var valueList = value;
    var promiseList = valueList.map(function (valueItem) {
      return fn.apply(void 0, [valueItem].concat(otherArgs));
    });
    return Promise.all(promiseList);
  } else {
    return fn.apply(void 0, [value].concat(otherArgs));
  }
}
/**
 * @param {string} symbol
 * @param {number} [chainId]
 * @param {MinterApiInstance} apiInstance
 * @param {import('axios').AxiosRequestConfig} [axiosOptions]
 * @return {Promise<number>}
 * @private
 */


function _getCoinId(symbol, chainId, apiInstance, axiosOptions) {
  if (utils.isCoinId(symbol)) {
    return Promise.resolve(symbol);
  }

  if (utils.isCoinSymbol(symbol)) {
    if (utils.isBaseCoinSymbol(chainId, symbol)) {
      return Promise.resolve(0);
    } else {
      var getCoinInfo$1 = getCoinInfo(apiInstance);
      return getCoinInfo$1(symbol, axiosOptions).then(function (coinInfo) {
        return coinInfo.id;
      });
    }
  } else {
    return Promise.reject(new Error('Invalid coin symbol'));
  }
}
/**
 * @param {MinterApiInstance} apiInstance
 * @return {function(TxParams): (Promise<TxParams>)}
 */


function ReplaceCoinId(apiInstance) {
  var replaceCoinIdByPath = ReplaceCoinIdByPath(apiInstance);
  /**
   * @param {TxParams} txParams
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<TxParams>}
   */

  return function replaceCoinId(txParams, axiosOptions) {
    var pathList = getTxParamsPathList(txParams);
    return replaceCoinIdByPath(txParams, pathList, txParams.chainId, axiosOptions);
  };
}
/**
 *
 * @param {MinterApiInstance} apiInstance
 * @return {function(Object, Array<string>, number=, AxiosRequestConfig=): Promise<Object>}
 * @constructor
 */

function ReplaceCoinIdByPath(apiInstance) {
  var replaceParamsByPath = ReplaceParamsByPath(apiInstance);
  return replaceCoinIdByPath;
  /**
   * @param {Object} txParams
   * @param {Array<string>} pathList
   * @param {number} [chainId]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<Object>}
   */

  function replaceCoinIdByPath(txParams, pathList) {
    var chainId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : apiInstance.defaults.chainId;
    var axiosOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;
    return replaceParamsByPath(txParams, pathList, replacer, chainId, axiosOptions); // eslint-disable-next-line no-shadow, unicorn/consistent-function-scoping

    function replacer(idValue, chainId, apiInstance, axiosOptions) {
      if (utils.isCoinId(idValue)) {
        return _getCoinSymbol(idValue, chainId, apiInstance, axiosOptions);
      } else {
        return Promise.resolve(idValue);
      }
    }
  }
}
/**
 * @param {MinterApiInstance} apiInstance
 * @return {function(id: number|string|Array<number|string>, chainId: number=, axiosOptions: AxiosRequestConfig=): Promise<number>}
 */

function GetCoinSymbol(apiInstance) {
  return getCoinSymbol;
  /**
   * @param {number|string|Array<number|string>} id
   * @param {number} [chainId]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<string|Array<string>>}
   */

  function getCoinSymbol(id) {
    var chainId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : apiInstance.defaults.chainId;
    var axiosOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    return processArrayByPromise(_getCoinSymbol, id, chainId, apiInstance, axiosOptions);
  }
}
/**
 * @param {number|string} id
 * @param {number} [chainId]
 * @param {MinterApiInstance} apiInstance
 * @param {import('axios').AxiosRequestConfig} [axiosOptions]
 * @return {Promise<string>}
 * @private
 */

function _getCoinSymbol(id, chainId, apiInstance, axiosOptions) {
  if (utils.isCoinSymbol(id)) {
    return Promise.resolve(id);
  }

  if (utils.isCoinId(id)) {
    if (Number.parseInt(id, 10) === 0 && chainId) {
      return Promise.resolve(utils.getBaseCoinSymbol(chainId));
    } else {
      var getCoinInfo$1 = getCoinInfo(apiInstance);
      return getCoinInfo$1(id, axiosOptions).then(function (coinInfo) {
        return coinInfo.symbol;
      });
    }
  } else {
    return Promise.reject(new Error('Invalid coin id'));
  }
}
/**
 * @param {TxParams} txParams
 * @return {Array<string>}
 */


function getTxParamsPathList(txParams) {
  var pathList = [];
  pathList.push('gasCoin');
  var txType = minterjsUtil.normalizeTxType(txParams.type);

  switch (txType) {
    case minterjsUtil.TX_TYPE.SEND:
    case minterjsUtil.TX_TYPE.DECLARE_CANDIDACY:
    case minterjsUtil.TX_TYPE.DELEGATE:
    case minterjsUtil.TX_TYPE.UNBOND:
    case minterjsUtil.TX_TYPE.MOVE_STAKE:
    case minterjsUtil.TX_TYPE.MINT_TOKEN:
    case minterjsUtil.TX_TYPE.BURN_TOKEN:
    case minterjsUtil.TX_TYPE.VOTE_COMMISSION:
      {
        pathList.push('data.coin');
        break;
      }

    case minterjsUtil.TX_TYPE.ADD_LIMIT_ORDER:
    case minterjsUtil.TX_TYPE.SELL:
    case minterjsUtil.TX_TYPE.SELL_ALL:
    case minterjsUtil.TX_TYPE.BUY:
      {
        pathList.push('data.coinToSell', 'data.coinToBuy');
        break;
      }

    case minterjsUtil.TX_TYPE.CREATE_SWAP_POOL:
    case minterjsUtil.TX_TYPE.ADD_LIQUIDITY:
    case minterjsUtil.TX_TYPE.REMOVE_LIQUIDITY:
      {
        pathList.push('data.coin0', 'data.coin1');
        break;
      }

    case minterjsUtil.TX_TYPE.MULTISEND:
      {
        txParams.data.list.forEach(function (item, index) {
          pathList.push("data.list[".concat(index, "].coin"));
        });
        break;
      }

    case minterjsUtil.TX_TYPE.BUY_SWAP_POOL:
    case minterjsUtil.TX_TYPE.SELL_SWAP_POOL:
    case minterjsUtil.TX_TYPE.SELL_ALL_SWAP_POOL:
      {
        txParams.data.coins.forEach(function (item, index) {
          pathList.push("data.coins[".concat(index, "]"));
        });
        break;
      }
  }

  return pathList;
}

exports.GetCoinId = GetCoinId;
exports.GetCoinSymbol = GetCoinSymbol;
exports.ReplaceCoinId = ReplaceCoinId;
exports.ReplaceCoinIdByPath = ReplaceCoinIdByPath;
exports.ReplaceCoinSymbol = ReplaceCoinSymbol;
exports.ReplaceCoinSymbolByPath = ReplaceCoinSymbolByPath;
exports.ReplaceParamsByPath = ReplaceParamsByPath;
