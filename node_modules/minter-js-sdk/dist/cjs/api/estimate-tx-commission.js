'use strict';

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _typeof = require('@babel/runtime/helpers/typeof');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var Big = require('big.js');
var minterjsUtil = require('minterjs-util');
var getCommissionPrice = require('./get-commission-price.js');
var getPoolInfo = require('./get-pool-info.js');
var replaceCoin = require('./replace-coin.js');
var estimateCoinBuy = require('./estimate-coin-buy.js');
var tx = require('../tx.js');
var utils = require('../utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var Big__default = /*#__PURE__*/_interopDefaultLegacy(Big);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
Big__default["default"].RM = 2;
/**
 *
 * @param {MinterApiInstance} apiInstance
 * @return {function((TxParams|string), {direct?: boolean}=, AxiosRequestConfig=): (Promise<{commission: (number|string), baseCoinCommission: (number|string), priceCoinCommission: (number|string), commissionPriceData: CommissionPriceData}>|Promise<{commission: (number|string)}>)}
 */

function EstimateTxCommission(apiInstance) {
  var getCommissionPrice$1 = getCommissionPrice(apiInstance);
  var getPoolInfo$1 = getPoolInfo(apiInstance);
  var getCoinId = replaceCoin.GetCoinId(apiInstance);
  var estimateCoinBuy$1 = estimateCoinBuy(apiInstance);
  return estimateTxCommission;
  /**
   * @param {TxParams|string} txParams
   * @param {Object} [options]
   * @param {boolean} [options.direct = true]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<{commission: (number|string), baseCoinCommission: (number|string), priceCoinCommission: (number|string), commissionPriceData: CommissionPriceData}>|Promise<{commission: (number|string)}>}
   */

  function estimateTxCommission(txParams) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$direct = _ref.direct,
        direct = _ref$direct === void 0 ? true : _ref$direct;

    var axiosOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    var paramsPromise;

    if (_typeof__default["default"](txParams) === 'object') {
      paramsPromise = getCoinId(txParams.gasCoin || 0, txParams.chainId, axiosOptions).then(function (coinId) {
        utils.validateUint(coinId, 'gasCoin');
        return _objectSpread(_objectSpread({}, txParams), {}, {
          gasCoin: coinId
        });
      });
    } else {
      paramsPromise = Promise.resolve(txParams);
    }

    return paramsPromise.then(function (updatedTxParams) {
      if (direct) {
        return estimateFeeDirect(updatedTxParams, axiosOptions);
      } else {
        return estimateFeeCalculate(updatedTxParams, axiosOptions);
      }
    });
  }
  /**
   * @param {string|TxParams} txParams
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<{commission: number|string}>}
   */


  function estimateFeeDirect(txParams, axiosOptions) {
    if (!txParams) {
      return Promise.reject(new Error('Transaction not specified'));
    }

    var tx$1;

    if (typeof txParams === 'string') {
      tx$1 = txParams;
    } else {
      txParams = _objectSpread({
        chainId: 0,
        nonce: 0,
        gasPrice: 1,
        signatureType: 1
      }, txParams);
      tx$1 = tx.prepareTx(txParams).serializeToString();
    }

    return apiInstance.get("estimate_tx_commission/".concat(tx$1), axiosOptions).then(function (response) {
      response.data.commission = minterjsUtil.convertFromPip(response.data.commission);
      return response.data;
    });
  }
  /**
   * @param {TxParams} txParams
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<{commission: number|string, baseCoinCommission: number|string, priceCoinCommission: number|string, commissionPriceData: CommissionPriceData}>}
   */


  function estimateFeeCalculate(_x, _x2) {
    return _estimateFeeCalculate.apply(this, arguments);
  }
  /**
   * @param {number|string} coinIdOrSymbol
   * @param {number|string} baseCoinAmount
   * @param {import('axios').AxiosRequestConfig} axiosOptions
   * @return {Promise<{amount: string, baseCoinAmount: string}>}
   */


  function _estimateFeeCalculate() {
    _estimateFeeCalculate = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(txParams, axiosOptions) {
      var commissionPriceData, feePrice, priceCoinFee, baseCoinFee, priceCoinPool, fee, _yield$getEstimation, amount;

      return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(!txParams || _typeof__default["default"](txParams) !== 'object')) {
                _context.next = 2;
                break;
              }

              return _context.abrupt("return", Promise.reject(new TypeError('Invalid txParams')));

            case 2:
              _context.next = 4;
              return getCommissionPrice$1(axiosOptions);

            case 4:
              commissionPriceData = _context.sent;
              // priceCoin
              feePrice = new minterjsUtil.FeePrice(commissionPriceData);
              priceCoinFee = feePrice.getFeeValue(txParams.type, getFeePriceOptionsFromTxParams(txParams)); // baseCoin

              if (!isPriceCoinSameAsBaseCoin(commissionPriceData)) {
                _context.next = 11;
                break;
              }

              baseCoinFee = priceCoinFee;
              _context.next = 15;
              break;

            case 11:
              _context.next = 13;
              return getPoolInfo$1(0, commissionPriceData.coin.id, axiosOptions);

            case 13:
              priceCoinPool = _context.sent;
              baseCoinFee = getBaseCoinAmountFromPool(priceCoinFee, priceCoinPool);

            case 15:
              if (!isGasCoinSameAsBaseCoin(txParams.gasCoin)) {
                _context.next = 19;
                break;
              }

              fee = baseCoinFee;
              _context.next = 24;
              break;

            case 19:
              _context.next = 21;
              return getEstimation(txParams.gasCoin, baseCoinFee, axiosOptions);

            case 21:
              _yield$getEstimation = _context.sent;
              amount = _yield$getEstimation.amount;
              fee = amount;

            case 24:
              return _context.abrupt("return", {
                commission: fee,
                baseCoinCommission: baseCoinFee,
                priceCoinCommission: priceCoinFee,
                commissionPriceData: commissionPriceData
              });

            case 25:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _estimateFeeCalculate.apply(this, arguments);
  }

  function getEstimation(coinIdOrSymbol, baseCoinAmount, axiosOptions) {
    return estimateCoinBuy$1({
      coinToSell: !utils.isCoinId(coinIdOrSymbol) ? coinIdOrSymbol : undefined,
      coinIdToSell: utils.isCoinId(coinIdOrSymbol) ? coinIdOrSymbol : undefined,
      valueToBuy: baseCoinAmount,
      coinIdToBuy: 0,
      swapFrom: 'optimal'
    }, axiosOptions).then(function (result) {
      return {
        amount: result.will_pay,
        baseCoinAmount: baseCoinAmount
      };
    });
  }
}
/**
 * @param {CommissionPriceData} commissionPriceData
 * @return {boolean}
 */

function isPriceCoinSameAsBaseCoin(commissionPriceData) {
  return Number.parseInt(commissionPriceData === null || commissionPriceData === void 0 ? void 0 : commissionPriceData.coin.id, 10) === 0;
}
/**
 * @param {number|string} gasCoinId
 * @return {boolean}
 */


function isGasCoinSameAsBaseCoin(gasCoinId) {
  return Number.parseInt(gasCoinId, 10) === 0;
}
/**
 *
 * @param {number|string} priceCoinAmount
 * @param {PoolInfo} pool
 * @return {string|number}
 */


function getBaseCoinAmountFromPool(priceCoinAmount, pool) {
  // amount of base coin in pool
  var reserveBase = new Big__default["default"](pool.amount0); // amount of price coin in pool

  var reservePrice = new Big__default["default"](pool.amount1); // amount of price coin in pool

  var priceCoinAmountPip = new Big__default["default"](minterjsUtil.convertToPip(priceCoinAmount)); // @see https://github.com/MinterTeam/minter-go-node/blob/6e44d5691c9df1a9c725d0f52c5921e8523c7f18/coreV2/state/swap/swap.go#L642
  // reserveBase - (reservePrice * reserveBase) / (priceCoinAmount * 0.998 + reservePrice)

  var result = reserveBase.minus(reservePrice.times(reserveBase).div(priceCoinAmountPip.times(0.998).plus(reservePrice))); // received amount from pool rounds down, spent amount to pool rounds up
  // round down

  result = result.round(undefined, 0);
  return minterjsUtil.convertFromPip(result);
}
/**
 * @param {TxParams} txParams
 * @return FeePriceOptions
 */


function getFeePriceOptionsFromTxParams(txParams) {
  var _txParams$data;

  var txType = txParams.type;

  if (!txType) {
    throw new Error('Tx `type` not specified');
  }

  var isTickerType = txType === minterjsUtil.TX_TYPE.CREATE_COIN || txType === minterjsUtil.TX_TYPE.CREATE_TOKEN;
  var coinSymbol = isTickerType ? (_txParams$data = txParams.data) === null || _txParams$data === void 0 ? void 0 : _txParams$data.symbol : undefined;

  if (isTickerType && !coinSymbol) {
    throw new Error('`symbol` not specified for ticker creation tx');
  }

  var deltaItemCount;

  if (txType === minterjsUtil.TX_TYPE.BUY_SWAP_POOL || txType === minterjsUtil.TX_TYPE.SELL_SWAP_POOL || txType === minterjsUtil.TX_TYPE.SELL_ALL_SWAP_POOL) {
    var _txParams$data2;

    var coinCount = (_txParams$data2 = txParams.data) === null || _txParams$data2 === void 0 ? void 0 : _txParams$data2.coins.length;

    if (!coinCount) {
      throw new Error('Invalid `coins` field in swap pool tx');
    } // count of pools


    deltaItemCount = coinCount - 1;
  }

  if (txType === minterjsUtil.TX_TYPE.MULTISEND) {
    var _txParams$data3;

    // count of recipients
    deltaItemCount = (_txParams$data3 = txParams.data) === null || _txParams$data3 === void 0 ? void 0 : _txParams$data3.list.length;

    if (!deltaItemCount) {
      throw new Error('Invalid `list` field in multisend tx');
    }
  }

  return {
    payload: txParams.payload,
    coinSymbol: coinSymbol,
    deltaItemCount: deltaItemCount
  };
}

module.exports = EstimateTxCommission;
