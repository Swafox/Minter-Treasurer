'use strict';

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var qs = require('qs');
var minterjsUtil = require('minterjs-util');
var utils = require('../utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
/**
 * @typedef {Object} EstimateSellAllResult
 * @property {number|string} will_get - amount of coinToBuy
 * @property {"pool"|"bancor"} [swap_from]
 */

/**
 * @param {MinterApiInstance} apiInstance
 * @return {function({coinToSell: string, valueToSell: (string|number), coinToBuy: string, swapFrom?: ESTIMATE_SWAP_TYPE, route?: Array<string|number>, gasPrice: (string|number)}, axiosOptions: AxiosRequestConfig=): Promise<EstimateSellAllResult>}
 */

function EstimateCoinSellAll(apiInstance) {
  return estimateCoinSellAll;
  /**
   * @param {Object} params
   * @param {string|number} params.coinToSell - ID or symbol of the coin to sell
   * @param {string|number} params.valueToSell
   * @param {string|number} params.coinToBuy - ID or symbol of the coin to buy
   * @param {ESTIMATE_SWAP_TYPE} [params.swapFrom] - estimate pool swap
   * @param {Array<string|number>} [params.route] - IDs of intermediate coins for pool swaps
   * @param {string|number} [params.gasPrice]
   * @param {import('axios').AxiosRequestConfig} [axiosOptions]
   * @return {Promise<EstimateSellAllResult>}
   */

  function estimateCoinSellAll(params, axiosOptions) {
    if (params.coinIdToSell || params.coinIdToSell === 0) {
      params.coinToSell = params.coinIdToSell; // eslint-disable-next-line no-console

      console.warn('coinIdToSell is deprecated, use coinToSell instead');
    }

    if (params.coinIdToBuy || params.coinIdToBuy === 0) {
      params.coinToBuy = params.coinIdToBuy; // eslint-disable-next-line no-console

      console.warn('coinIdToSell is deprecated, use coinToSell instead');
    }

    if (!params.coinToBuy && params.coinToBuy !== 0) {
      return Promise.reject(new Error('Coin to buy not specified'));
    }

    if (!params.valueToSell) {
      return Promise.reject(new Error('Value to sell not specified'));
    }

    if (!params.coinToSell && params.coinToSell !== 0) {
      return Promise.reject(new Error('Coin to sell not specified'));
    }

    params = {
      coin_id_to_sell: utils.isCoinId(params.coinToSell) ? params.coinToSell : undefined,
      coin_to_sell: !utils.isCoinId(params.coinToSell) ? params.coinToSell : undefined,
      value_to_sell: minterjsUtil.convertToPip(params.valueToSell),
      coin_id_to_buy: utils.isCoinId(params.coinToBuy) ? params.coinToBuy : undefined,
      coin_to_buy: !utils.isCoinId(params.coinToBuy) ? params.coinToBuy : undefined,
      swap_from: params.swapFrom,
      route: params.route,
      gas_price: params.gasPrice
    };
    return apiInstance.get('estimate_coin_sell_all', _objectSpread(_objectSpread({}, axiosOptions), {}, {
      params: params,
      paramsSerializer: function paramsSerializer(query) {
        return qs.stringify(query, {
          arrayFormat: 'repeat'
        });
      }
    })).then(function (response) {
      var resData = response.data;

      if (!utils.isValidNumber(resData.will_get)) {
        throw new Error('Invalid estimation data, `will_get` not specified');
      }

      return _objectSpread(_objectSpread({}, resData), {}, {
        // receive pips from node and convert them
        will_get: minterjsUtil.convertFromPip(resData.will_get)
      });
    });
  }
}

module.exports = EstimateCoinSellAll;
