"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
exports.generateMnemonic = generateMnemonic;
exports.generateWallet = generateWallet;
exports.hdKeyFromSeed = hdKeyFromSeed;
exports.isValidMnemonic = isValidMnemonic;
exports.seedFromMnemonic = seedFromMnemonic;
exports.seedFromMnemonicAsync = seedFromMnemonicAsync;
exports.walletFromMnemonic = walletFromMnemonic;
exports.walletFromMnemonicAsync = walletFromMnemonicAsync;
exports.walletFromPrivateKey = walletFromPrivateKey;

var bip39 = _interopRequireWildcard(require("bip39"));

var _hdkey = require("ethereum-cryptography/hdkey");

var _account = require("ethereumjs-util/dist/account");

var _minterjsUtil = require("minterjs-util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @TODO remove some wordlists
function assert(val, msg) {
  if (!val) {
    throw new Error(msg || 'Assertion failed');
  }
}
/**
 * BIP39 Master seed from mnemonic phrase
 * @param mnemonic - 12 words
 * @return {Buffer}
 */


function seedFromMnemonic(mnemonic) {
  return bip39.mnemonicToSeedSync(mnemonic);
}
/**
 * BIP39 Master seed from mnemonic phrase (async)
 * @param mnemonic - 12 words
 * @return {Promise<Buffer>}
 */


function seedFromMnemonicAsync(mnemonic) {
  return bip39.mnemonicToSeed(mnemonic);
}
/**
 * BIP44 HD key from master seed
 * @param {Buffer} seed - 64 bytes
 * @return {HDKey}
 */


function hdKeyFromSeed(seed) {
  // same as "m/44'/60'/0'/0/0"
  return _hdkey.HDKey.fromMasterSeed(seed).derive("m/44'/60'/0'/0").deriveChild(0);
}
/**
 * @param {Buffer} [priv]
 * @param {string} [mnemonic]
 * @param {boolean} [doAsync]
 * @constructor
 */


var Wallet = function WalletConstructor(priv, mnemonic, doAsync) {
  var _this = this;

  if (priv && mnemonic) {
    throw new Error('Cannot supply both a private and a mnemonic phrase to the constructor');
  }

  if (priv && !(0, _account.isValidPrivate)(priv)) {
    throw new Error('Private key does not satisfy the curve requirements (ie. it is invalid)');
  }

  if (mnemonic && !bip39.validateMnemonic(mnemonic)) {
    throw new Error('Invalid mnemonic phrase');
  }

  if (mnemonic && doAsync) {
    return seedFromMnemonicAsync(mnemonic).then(function (seed) {
      _this._privKey = hdKeyFromSeed(seed)._privateKey;
      _this._mnemonic = mnemonic;
      return _this;
    });
  }

  if (mnemonic) {
    var seed = seedFromMnemonic(mnemonic);
    priv = hdKeyFromSeed(seed)._privateKey;
  }

  this._privKey = priv;
  this._mnemonic = mnemonic;
};

Object.defineProperty(Wallet.prototype, 'mnemonic', {
  get: function get() {
    assert(this._mnemonic, 'This is a private key only wallet');
    return this._mnemonic;
  }
});
Object.defineProperty(Wallet.prototype, 'privKey', {
  get: function get() {
    return this._privKey;
  }
}); // uncompressed public key

Object.defineProperty(Wallet.prototype, 'pubKey', {
  get: function get() {
    if (!this._pubKey) {
      this._pubKey = (0, _account.privateToPublic)(this.privKey);
    }

    return this._pubKey;
  }
});
/**
 * @return {string}
 */

Wallet.prototype.getMnemonic = function getMnemonic() {
  return this.mnemonic;
};
/**
 * @return {Buffer}
 */


Wallet.prototype.getPrivateKey = function getPrivateKey() {
  return this.privKey;
};
/**
 * @return {string}
 */


Wallet.prototype.getPrivateKeyString = function getPrivateKeyString() {
  return "0x".concat(this.getPrivateKey().toString('hex'));
};
/**
 * @return {Buffer}
 */


Wallet.prototype.getPublicKey = function getPublicKey() {
  return this.pubKey;
};
/**
 * @return {string}
 */


Wallet.prototype.getPublicKeyString = function getPublicKeyString() {
  return (0, _minterjsUtil.publicToString)(this.getPublicKey());
};
/**
 * @return {Buffer}
 */


Wallet.prototype.getAddress = function getAddress() {
  return (0, _account.publicToAddress)(this.pubKey);
};
/**
 * @return {string}
 */


Wallet.prototype.getAddressString = function getAddressString() {
  return "Mx".concat(this.getAddress().toString('hex'));
};
/**
 * Generate Wallet from random mnemonic
 * @return {Wallet}
 */


function generateWallet() {
  var mnemonic = bip39.generateMnemonic();
  return walletFromMnemonic(mnemonic);
}
/**
 * MinterWallet from mnemonic phrase
 * @param {string} mnemonic - 12 words
 * @return {Wallet}
 */


function walletFromMnemonic(mnemonic) {
  return new Wallet(null, mnemonic);
}
/**
 * MinterWallet from mnemonic phrase
 * @param {string} mnemonic - 12 words
 * @return {Promise<Wallet>}
 */


function walletFromMnemonicAsync(mnemonic) {
  return new Wallet(null, mnemonic, true);
}
/**
 * MinterWallet from private key
 * @param {Buffer} priv - 64 bytes
 * @return {Wallet}
 */


function walletFromPrivateKey(priv) {
  return new Wallet(priv);
}
/**
 * Generate 12 words mnemonic phrase
 * @return {string}
 */


function generateMnemonic() {
  return bip39.generateMnemonic();
}
/**
 * Check that mnemonic phrase has 12 words and represents valid entropy
 * @param {string} mnemonic
 * @return {boolean}
 */


function isValidMnemonic(mnemonic) {
  return typeof mnemonic === 'string' && mnemonic.trim().split(/\s+/g).length >= 12 && bip39.validateMnemonic(mnemonic);
}

var _default = Wallet;
exports["default"] = _default;