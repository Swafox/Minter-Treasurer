"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = definePropertiesNonBinary;

var _ethereumjsUtil = require("ethereumjs-util");

var _safeBuffer = require("safe-buffer");

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

var _typeof = typeof Symbol === 'function' && _typeof2(Symbol.iterator) === 'symbol' ? function (obj) {
  return _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype ? 'symbol' : _typeof2(obj);
};
/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * * `allowNonBinaryArray` - if the field can be non binary array
 * * `nonBinaryArrayTransform` - function to transform each item of the non binary array
 * @param {*} [data] data to be validated against the definitions
 */


function definePropertiesNonBinary(self, fields, data) {
  self.raw = [];
  self._fields = []; // attach the `toJSON`

  self.toJSON = function (label) {
    if (label) {
      var obj = {};

      self._fields.forEach(function (field) {
        obj[field] = "0x".concat(self[field].toString('hex'));
      });

      return obj;
    }

    return (0, _ethereumjsUtil.baToJSON)(this.raw);
  };

  self.serialize = function serialize() {
    return _ethereumjsUtil.rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);

    function getter() {
      return self.raw[i];
    }

    function setter(v) {
      if (field.allowNonBinaryArray && Array.isArray(v)) {
        if (field.nonBinaryArrayTransform && typeof field.nonBinaryArrayTransform === 'function') {
          v = v.map(function (item) {
            return field.nonBinaryArrayTransform(item);
          });
        } else {
          v = v.map(function (item) {
            return (0, _ethereumjsUtil.toBuffer)(item);
          });
        }
      } else {
        v = (0, _ethereumjsUtil.toBuffer)(v);

        if (v.toString('hex') === '00' && !field.allowZero) {
          v = _safeBuffer.Buffer.allocUnsafe(0);
        }

        if (field.allowLess && field.length) {
          v = (0, _ethereumjsUtil.stripZeros)(v);
          (0, _assert["default"])(field.length >= v.length, "The field ".concat(field.name, " must not have more ").concat(field.length, " bytes"));
        } else if (!(field.allowZero && v.length === 0) && field.length) {
          (0, _assert["default"])(field.length === v.length, "The field ".concat(field.name, " must have byte length of ").concat(field.length));
        }
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field["default"]) {
      self[field.name] = field["default"];
    } // attach alias


    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  }); // if the constuctor is passed data

  if (data) {
    if (typeof data === 'string') {
      data = _safeBuffer.Buffer.from((0, _ethereumjsUtil.stripHexPrefix)(data), 'hex');
    }

    if (_safeBuffer.Buffer.isBuffer(data)) {
      data = _ethereumjsUtil.rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      } // make sure all the items are buffers


      data.forEach(function (d, i) {
        self[self._fields[i]] = (0, _ethereumjsUtil.toBuffer)(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
}